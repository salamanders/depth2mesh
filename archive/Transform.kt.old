package info.benjaminhill.math

import kotlin.math.atan2
import kotlin.math.sqrt

typealias Transform = EzMatrix

/**
 * computes R p + t when T = |R t| and len(p) = len(t) |0 1|
 *
 * http://web.iitd.ac.in/~hegde/cad/lecture/L6_3dtrans.pdf
 *
 * a d g p
 * b e h q
 * c f i r
 * l m n s
 * pqr = Perspective transformations
 * a:i Linear transformations â€“ local scaling, shear, rotation / reflection
 * lmn: Translations l, m, n along x, y, and z axis
 * s: Overall scaling
 */
fun Transform.transform(vec: EzVector): EzVector {
    val result = EzVector(vec.size)
    for (i in vec.indices)
        for (j in vec.indices)
            result[i] += this[i][j] * vec[j]
    for (i in vec.indices)
        result[i] += this[i][vec.size]
    return result
}

/**
 * Rotation matrix to Euler Angles
 * http://nghiaho.com/?page_id=846
 * r11 r12 r13
 * r21 r22 r23
 * r31 r32 r33
 */
fun Transform.toEuler(): Triple<Double, Double, Double> {
    val (r11, r12, r13) = this[0]
    val (r21, r22, r23) = this[1]
    val (r31, r32, r33) = this[2]

    val thetaX = atan2(r32, r33)
    val thetaY = atan2(-r31, sqrt(r32*r32 + r33*r33))
    val thetaZ = atan2(r21, r11)

    return Triple(thetaX, thetaY, thetaZ)
}

fun Transform.transform(cloud: EzCloud3d): EzCloud3d {
    require(isSquare())
    cloud.firstOrNull()?.let {
        require(it.size + 1 == size)
    }
    return cloud.map { point ->
        EzVector(point.size).also {
            for (i in point.indices)
                for (j in point.indices)
                    it[i] += this[i][j] * point[j]
            for (i in point.indices)
                it[i] += this[i][point.size]
        }
    }.toList()
}
