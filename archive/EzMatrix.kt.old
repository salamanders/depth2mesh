package info.benjaminhill.math

import java.math.BigDecimal
import java.math.RoundingMode

/**
 * Extension function on a SimpleVector (DoubleArray) is the simplest way to store a 2D array.
 * Good for Operators (like myMatrix[rowNum, colNum]++)
 * Rows, then column.
 */
typealias EzMatrix = Array<EzVector>

fun ezMatrixOf(rows: Int, columns: Int = rows): EzMatrix = Array(rows) {
    vectorOf(columns)
}

fun squareMatrixOf(sz: Int) = ezMatrixOf(sz)

/**
 * Return the identity matrix of size 'sz'
 */
fun identityMatrixOf(sz: Int) = squareMatrixOf(sz).also {
    for (i in 0 until sz) it[i][i] = 1.0
}

val EzMatrix.rowDimension: Int
    get() = size

val EzMatrix.columnDimension: Int
    get() = this[0].size

fun EzMatrix.deepCopy(): EzMatrix = Array(rowDimension) {
    this[it].clone()
}

fun EzMatrix.swapRows(a: Int, b: Int) {
    val t = this[a]
    this[a] = this[b]
    this[b] = t
}


fun EzMatrix.transpose(): EzMatrix = ezMatrixOf(columnDimension, rowDimension).also { result ->
    for (rowNum in 0 until rowDimension) {
        val row = this[rowNum]
        row.transposeAsColumn(result, rowNum)
    }
}


/**
 * Create a new DenseVec containing a copy of the column. Changes to
 * the DenseVec do NOT affect the Matrix.
 */
fun EzMatrix.copyColumn(sourceColNum: Int): EzVector = EzVector(rowDimension) { rowNum ->
    this[rowNum][sourceColNum]
}

operator fun EzMatrix.get(rowNum: Int, columnNum: Int) = this[rowNum][columnNum]

operator fun EzMatrix.set(rowNum: Int, columnNum: Int, value: Double) {
    this[rowNum][columnNum] = value
}

fun EzMatrix.isSquare() = isNotEmpty() && rowDimension == columnDimension

/**
 * compute determinant of small matrix.
 */
fun EzMatrix.det(): Double {
    require(isSquare())
    return when (size) {
        3 -> -this[0][2] * this[1][1] * this[2][0] + this[0][1] * this[1][2] * this[2][0] + this[0][2] * this[1][0] * this[2][1] - this[0][0] * this[1][2] * this[2][1] - this[0][1] * this[1][0] * this[2][2] + this[0][0] * this[1][1] * this[2][2]
        2 -> this[0][0] * this[1][1] - this[1][0] * this[0][1]
        else -> {
            error("LUDecomposition not supported for size:$size")
            // Otherwise compute the LU decomposition, multiply the diagonals
            /*
            val lu = LUDecomposition(this)
            var det = 1.0
            for (i in indices) det *= lu.l[i, i]
            for (i in indices) det *= lu.u[i, i]
            return det
            */
        }
    }
}

fun matrixABCt(
    A: EzMatrix,
    B: EzMatrix,
    C: EzMatrix
): EzMatrix {
    return matrixAB(A, matrixABt(B, C))
}

// X = A * B
fun matrixAB(
    A: EzMatrix,
    B: EzMatrix
): EzMatrix {
    require(A.columnDimension == B.rowDimension)

    val bNumCols: Int = B.columnDimension
    val aNumCols: Int = A.columnDimension

    val targetX = ezMatrixOf(A.rowDimension, bNumCols)
    for (aRowNum in A.indices) {
        for (bColNum in B.indices) {
            var acc = 0.0
            for (aColNum in A.indices) {
                acc += A[aRowNum][aColNum] * B[aColNum][bColNum]
            }
            targetX[aRowNum][bColNum] = acc
        }
    }
    return targetX
}

/**
 * X = A * B
 */
fun matrixAB(A: EzMatrix, B: EzVector): EzVector {
    require(A.columnDimension == B.size)
    val targetX = EzVector(A.rowDimension)
    for (xRowNum in targetX.indices) {
        var acc = 0.0
        for (aColNum in A[0].indices) {
            acc += A[xRowNum][aColNum] * B[aColNum]
        }
        targetX[xRowNum] = acc
    }
    return targetX
}

/**
 * X = A * B^T
 */
fun matrixABt(
    A: EzMatrix,
    B: EzMatrix
): EzMatrix {
    require(A.columnDimension == B.columnDimension)
    val targetX = ezMatrixOf(A.rowDimension, B.rowDimension)
    for (aRowNum in A.indices) {
        for (bRowNum in B.indices) {
            var acc = 0.0
            for (aColNum in A[aRowNum].indices) {
                acc += A[aRowNum][aColNum] * B[bRowNum][aColNum]
            }
            targetX[aRowNum][bRowNum] = acc
        }
    }
    return targetX
}

fun EzMatrix.pretty(): String = joinToString("\n") { row: EzVector ->
    row.map { BigDecimal(it).setScale(3, RoundingMode.HALF_EVEN) }.joinToString("\t")
}

