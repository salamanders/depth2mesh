package info.benjaminhill.math

import kotlin.random.Random

/**
 * Extension function on a DoubleArray is the simplest way to store a list of doubles.
 * Good for Operators.
 * Supports 3d Points
 */
typealias EzVector = DoubleArray

fun vectorOf(dim: Int) = DoubleArray(dim)

fun randomVectorOf(dim: Int, scale: Double): EzVector = EzVector(dim) {
    Random.nextDouble() * 2 * scale - scale
}

operator fun EzVector.timesAssign(scale: Double) {
    for (i in this.indices) {
        this[i] *= scale
    }
}

operator fun EzVector.divAssign(divisor: Double) {
    for (i in this.indices) {
        this[i] /= divisor
    }
}

operator fun EzVector.timesAssign(other: EzVector) {
    require(size == other.size)
    for (i in this.indices) {
        this[i] *= other[i]
    }
}

operator fun EzVector.minus(other: EzVector) = EzVector(this.size) { index ->
    this[index] - other[index]
}

operator fun EzVector.plusAssign(other: EzVector) {
    require(this.size == other.size)
    for (i in this.indices) {
        this[i] += other[i]
    }
}

operator fun EzVector.plus(other: EzVector): EzVector {
    require(size == other.size)
    return EzVector(size) {
        this[it] + other[it]
    }
}

operator fun EzVector.times(other: EzVector): EzVector {
    require(size == other.size)
    return EzVector(size) {
        this[it] * other[it]
    }
}

operator fun EzVector.times(other: Double) = EzVector(this.size) {
    this[it] * other
}

fun EzVector.distanceSq(other: EzVector): Double {
    require(size == other.size)
    return indices.sumByDouble { i ->
        (this[i] - other[i]) * (this[i] - other[i])
    }
}

/**
 * dot product from [i0, i1]
 *
 * @param other
 * @param i0
 * @param i1
 * @return
 */
fun EzVector.dotProduct(other: EzVector, i0: Int, i1: Int): Double {
    if (other.size < size) return other.dotProduct(this, i0, i1)
    var acc = 0.0
    for (i in i0..i1) {
        acc += this[i] * other[i]
    }
    return acc
}

/**
 * Add the value v to specific element.
 */
fun EzVector.plusEquals(idx: Int, v: Double) {
    this[idx] += v
}

/**
 * Multiply the elements between indices [i0,i1] (inclusive) by v
 */
fun EzVector.timesEquals(scale: Double, i0: Int, i1: Int) {
    for (i in i0..i1) this[i] *= scale
}

/**
 * Insert this vector as column 'col' in matrix A. The column is
 * initially all zero. The vector should iterate through its
 * elements, calling the matrix's set method.
 */
fun EzVector.transposeAsColumn(A: EzMatrix, col: Int) {
    for (i in indices) A[i, col] = this[i]
}